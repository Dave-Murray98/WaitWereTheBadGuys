using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;

/// <summary>
/// Object pool manager for noise objects to optimize performance.
/// Manages a pool of reusable noise GameObjects to avoid constant instantiation/destruction.
/// </summary>
public class NoisePool : MonoBehaviour
{
    [Header("Pool Configuration")]
    [SerializeField, Range(5, 50)]
    [Tooltip("Initial number of noise objects to create in the pool")]
    private int initialPoolSize = 20;

    [SerializeField, Range(5, 100)]
    [Tooltip("Maximum number of noise objects that can exist in the pool")]
    private int maxPoolSize = 50;

    [SerializeField]
    [Tooltip("Prefab to use for creating noise objects (should have Noise component)")]
    private GameObject noisePrefab;

    [Header("Auto-Generation")]
    [SerializeField]
    [Tooltip("If no prefab is assigned, auto-generate noise objects")]
    private bool autoGenerateNoiseObjects = true;

    [SerializeField, ShowIf("autoGenerateNoiseObjects")]
    [Tooltip("Size of the collider for auto-generated noise objects")]
    private Vector3 autoGeneratedColliderSize = Vector3.one * 0.5f;

    [Header("Debug")]
    [SerializeField] private bool enableDebugLogs = true;

    // Pool management
    private Queue<GameObject> availableNoises = new Queue<GameObject>();
    private List<GameObject> activeNoises = new List<GameObject>();
    private Transform poolParent;

    // Singleton pattern for easy access
    private static NoisePool instance;
    public static NoisePool Instance
    {
        get
        {
            if (instance == null)
            {
                instance = FindFirstObjectByType<NoisePool>();
                if (instance == null)
                {
                    GameObject poolObject = new GameObject("NoisePool");
                    instance = poolObject.AddComponent<NoisePool>();
                }
            }
            return instance;
        }
    }

    #region Pool Properties
    [ShowInInspector, ReadOnly]
    public int AvailableCount => availableNoises.Count;

    [ShowInInspector, ReadOnly]
    public int ActiveCount => activeNoises.Count;

    [ShowInInspector, ReadOnly]
    public int TotalPoolSize => availableNoises.Count + activeNoises.Count;
    #endregion

    #region Unity Lifecycle
    private void Awake()
    {
        // Singleton setup
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else if (instance != this)
        {
            Destroy(gameObject);
            return;
        }

        SetupPool();
    }

    private void Start()
    {
        InitializePool();
    }
    #endregion

    #region Pool Setup
    private void SetupPool()
    {
        // Create a parent object to organize pooled objects
        GameObject poolParentObject = new GameObject("PooledNoises");
        poolParentObject.transform.SetParent(transform);
        poolParent = poolParentObject.transform;

        DebugLog("NoisePool setup complete");
    }

    private void InitializePool()
    {
        // Create initial pool objects
        for (int i = 0; i < initialPoolSize; i++)
        {
            CreatePooledNoise();
        }

        DebugLog($"NoisePool initialized with {initialPoolSize} objects");
    }

    private GameObject CreatePooledNoise()
    {
        GameObject noiseObject;

        if (noisePrefab != null)
        {
            // Use the assigned prefab
            noiseObject = Instantiate(noisePrefab, poolParent);
        }
        else if (autoGenerateNoiseObjects)
        {
            // Auto-generate a noise object
            noiseObject = CreateAutoGeneratedNoise();
        }
        else
        {
            Debug.LogError("NoisePool: No prefab assigned and auto-generation is disabled!");
            return null;
        }

        // Ensure the noise object has a Noise component
        Noise noiseComponent = noiseObject.GetComponent<Noise>();
        if (noiseComponent == null)
        {
            noiseComponent = noiseObject.AddComponent<Noise>();
        }

        // Set up the noise for pooling
        noiseComponent.InitializeForPooling(this);

        // Deactivate and add to available pool
        noiseObject.SetActive(false);
        availableNoises.Enqueue(noiseObject);

        return noiseObject;
    }

    private GameObject CreateAutoGeneratedNoise()
    {
        GameObject noiseObject = new GameObject("PooledNoise");
        noiseObject.transform.SetParent(poolParent);

        // Set to Noise layer
        noiseObject.layer = LayerMask.NameToLayer("Noise");

        // Add collider
        BoxCollider collider = noiseObject.AddComponent<BoxCollider>();
        collider.isTrigger = true;
        collider.size = autoGeneratedColliderSize;

        return noiseObject;
    }
    #endregion

    #region Public Pool Interface
    /// <summary>
    /// Get a noise object from the pool
    /// </summary>
    public GameObject GetNoise(Vector3 position, float volume, float lifetime = 2f)
    {
        GameObject noiseObject = GetAvailableNoise();

        if (noiseObject != null)
        {
            // Configure the noise
            noiseObject.transform.position = position;
            noiseObject.SetActive(true);

            Noise noiseComponent = noiseObject.GetComponent<Noise>();
            if (noiseComponent != null)
            {
                noiseComponent.ActivateNoise(volume, lifetime);
            }

            // Move to active list
            activeNoises.Add(noiseObject);

            DebugLog($"Retrieved noise from pool. Active: {ActiveCount}, Available: {AvailableCount}");
        }

        return noiseObject;
    }

    /// <summary>
    /// Return a noise object to the pool
    /// </summary>
    public void ReturnNoise(GameObject noiseObject)
    {
        if (noiseObject == null) return;

        // Remove from active list
        if (activeNoises.Remove(noiseObject))
        {
            // Reset the noise
            Noise noiseComponent = noiseObject.GetComponent<Noise>();
            if (noiseComponent != null)
            {
                noiseComponent.DeactivateNoise();
            }

            // Deactivate and return to pool
            noiseObject.SetActive(false);
            noiseObject.transform.SetParent(poolParent);
            availableNoises.Enqueue(noiseObject);

            DebugLog($"Returned noise to pool. Active: {ActiveCount}, Available: {AvailableCount}");
        }
        else
        {
            DebugLog($"Attempted to return noise that wasn't in active list: {noiseObject.name}");
        }
    }

    /// <summary>
    /// Static method for easy noise creation
    /// </summary>
    public static GameObject CreateNoise(Vector3 position, float volume, float lifetime = 2f)
    {
        return Instance.GetNoise(position, volume, lifetime);
    }
    #endregion

    #region Private Pool Management
    private GameObject GetAvailableNoise()
    {
        // Try to get from available pool
        if (availableNoises.Count > 0)
        {
            return availableNoises.Dequeue();
        }

        // Pool is empty, try to create a new one if under max size
        if (TotalPoolSize < maxPoolSize)
        {
            DebugLog("Pool empty, creating new noise object");
            return CreatePooledNoise();
        }

        // Pool is at max capacity and no available objects
        Debug.LogWarning("NoisePool: Pool at maximum capacity and no available objects!");
        return null;
    }
    #endregion

    #region Pool Utilities
    /// <summary>
    /// Force return all active noises to the pool
    /// </summary>
    [Button("Return All Active Noises")]
    public void ReturnAllActiveNoises()
    {
        List<GameObject> toReturn = new List<GameObject>(activeNoises);
        foreach (GameObject noise in toReturn)
        {
            ReturnNoise(noise);
        }

        DebugLog($"Returned {toReturn.Count} active noises to pool");
    }

    /// <summary>
    /// Expand the pool by creating additional objects
    /// </summary>
    [Button("Expand Pool")]
    public void ExpandPool(int additionalObjects = 5)
    {
        int created = 0;
        for (int i = 0; i < additionalObjects && TotalPoolSize < maxPoolSize; i++)
        {
            if (CreatePooledNoise() != null)
            {
                created++;
            }
        }

        DebugLog($"Expanded pool by {created} objects. Total size: {TotalPoolSize}");
    }

    /// <summary>
    /// Get pool statistics
    /// </summary>
    public string GetPoolStats()
    {
        return $"NoisePool Stats - Total: {TotalPoolSize}, Active: {ActiveCount}, Available: {AvailableCount}";
    }
    #endregion

    #region Debug
    private void DebugLog(string message)
    {
        if (enableDebugLogs)
        {
            Debug.Log($"[NoisePool] {message}");
        }
    }

    [Button("Print Pool Stats")]
    private void PrintPoolStats()
    {
        Debug.Log(GetPoolStats());
    }

    private void OnDrawGizmosSelected()
    {
        if (poolParent == null) return;

        // Draw connections to all pooled objects
        Gizmos.color = Color.cyan;
        foreach (Transform child in poolParent)
        {
            Gizmos.DrawLine(transform.position, child.position);

            // Draw differently for active vs inactive
            if (child.gameObject.activeInHierarchy)
            {
                Gizmos.color = Color.green;
                Gizmos.DrawWireSphere(child.position, 0.5f);
            }
            else
            {
                Gizmos.color = Color.gray;
                Gizmos.DrawWireCube(child.position, Vector3.one * 0.3f);
            }
        }
    }
    #endregion
}